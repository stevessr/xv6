---
title: 第2讲：C语言编程
---
 
6.1810 2024 第2讲：用C语言为xv6编程

为什么用C？
  - 适合底层编程
    - C语言和RISC-V指令之间有简单的映射关系
    - C语言类型和硬件结构之间有简单的映射关系
      - 例如，在设备的硬件寄存器中设置位标志
  - 最小的运行时
    - 易于移植到另一个硬件平台
    - 直接访问硬件
  - 显式内存管理
    - 没有垃圾回收器
    - 内核完全控制内存管理
  - 高效：编译型（没有解释器）
    - 编译器将C语言编译成汇编
  - 流行于构建内核、系统软件等
    - 在几乎任何平台上都有很好的C语言支持
  - 为什么不用？
    - 容易写出不正确的代码
    - 容易写出有安全漏洞的代码

今天的课程：xv6中C语言的使用
  - 内存布局
  - 指针
  - 数组
  - 字符串
  - 链表
  - 位运算符
  - [不是C语言的通用介绍]

C程序的内存布局
  - [画图，见教材图3.4]
  - text：代码，只读数据
  - data：全局C变量
  - stack：函数的局部变量
  - heap：使用sbrk、malloc/free进行动态内存分配

示例：编译cat.c
  - Makefile定义了如何编译
  - gcc编译成.o文件
  - ld将.o文件链接成可执行文件
    - ulibc.o是xv6的最小C库
  - 可执行文件是a.out格式，包含以下部分：
    - text（代码）、已初始化的数据、符号表、调试信息等
  - riscv64-linux-gnu-objdump -p user/_cat
    - 各部分由user.ld定义

探索_cat的a.out文件
  - riscv64-linux-gnu-objdump -S user/_cat
    - 与user/cat.asm相同
  - 0x0: cat
    - 如果我们同时运行两个cat程序会怎样？
    - 见页表课程
  - 0xf6: start
    - user.ld的默认入口点
  - start是什么？
    - 在ulib.c中定义，它调用main()和exit(0)
  - 数据内存在哪里？（例如，buf）
    - 在data/bss段
    - 必须由内核设置
  - 但我们知道buf应该在的地址
    - riscv64-linux-gnu-nm -n user/_cat

C指针
  - 指针是一个内存地址
    - 每个变量都有一个内存地址（即，p = &i）
    - 所以每个变量都可以通过其指针访问（即，*p）
    - 指针可以是变量（例如，int *p）
      - 因此它也有一个内存地址，等等。
  - 指针算术
    - char *c;
    - int *i;
    - c+1和i+1的值是多少？
  - 引用结构体成员
    - struct {
         int a;
         int b;
      } *p;
    - p->a = 10
  - [演示 ptr.c]
  
C数组
  - 存放相同数据类型（char, int等）的连续内存
    - 没有边界检查，不能增长
  - 两种访问数组的方式：
    - 通过索引：buf[0], buf[1]
    - 通过指针：*buf, *(buf+1)
  - [演示 array.c]
  
C字符串
  - 以0结尾的字符数组
    - [演示 str.c]
  - ulib.c有几个处理字符串的函数
    - strlen() --- 使用数组访问
    - strcmp() --- 使用指针访问
  - ls.c
    - argv：字符串数组
      - 每个条目都是一个字符串的地址
      - xv6的exec将它们放在栈上作为main的参数
    - 打印出argv
      - [画图；见书中图3.4]
    - T_DIR代码片段
      - mkdir d
      - echo hi > d/f
      - ls d

C链表（更多指针）
  - 单向链表
    - kernel/kalloc.c实现了一个内存分配器
    - 维护一个空闲内存“页”的列表
      - 一个页是4096字节
      - free在列表头部添加
      - kalloc从列表头部获取
  - 双向链表
    - kernel/bio.c实现了一个LRU缓冲区缓存
    - brelse()需要将一个buf移动到列表的前面
    - 见buf.h
      - 两个指针：prev和next

位运算符
  - char/int/long/指针都有位（在RISC-V上分别为8、32、64位）。
  - 你可以用|、&、~、^来操作它们
    - 10001 & 10000 = 10000
    - 10001 | 10000 = 10001
    - 10001 ^ 10000 = 00001
    - ~1000 = 0111
  - 示例：
    - user/usertests.c
    - kernel/fcntl.h
    - kernel/sysfile.c
  - 后面有更有趣的例子
 
关键字：
  - static：使变量的可见性仅限于声明它的文件
    - 但在文件内部是全局的
  - void：“无类型”、“无值”、“无参数”

常见的C语言错误
  - 释放后使用
  - 重复释放
  - 未初始化的内存
    - 栈上或malloc返回的内存不是零
  - 缓冲区溢出
    - 写入超出数组末尾
  - 内存泄漏
  - 类型混淆
    - 错误的类型转换

参考资料：
https://blog.regehr.org/archives/1393
