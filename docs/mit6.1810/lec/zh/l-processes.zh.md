---
title: "第4讲：进程"
---

# 第4讲：进程

## 操作系统组织

操作系统面临的核心挑战是如何在多个应用程序之间共享计算机资源。这引出了**多路复用**（multiplexing）的概念。

操作系统通过两种主要模式来管理硬件，以实现隔离和复用：

1.  **用户模式 (User Mode)**：应用程序在此模式下运行。CPU会限制它们能执行的指令。例如，用户程序不能直接访问硬件设备或管理内存。
2.  **内核模式 (Kernel Mode)**：操作系统内核在此模式下运行。CPU允许执行所有指令，包括那些可以直接与硬件交互、管理内存和调度进程的特权指令。

当用户程序需要执行特权操作时（例如，读写文件），它必须请求内核来完成。这种请求机制就是**系统调用 (System Call)**。

从用户程序的角度看，系统调用就像一个普通的函数调用。但在底层，它会触发一个特殊的硬件指令（在RISC-V中是 `ecall`），该指令会：
1.  将CPU从用户模式切换到内核模式。
2.  跳转到内核中一个预定义的、安全的入口点（陷阱处理程序）。
3.  内核执行相应的服务（如 `sys_open` 或 `sys_read`）。
4.  完成后，内核通过 `sret` 指令返回到用户空间，CPU也切换回用户模式，应用程序继续执行。

这种用户/内核分离的设计是构建可靠操作系统的基础。它确保了应用程序的错误不会搞垮整个系统，也保证了操作系统对硬件资源的完全控制权。

## 进程是什么？

进程是一个正在执行的程序的实例。它包含了程序运行所需的一切：
*   程序的内存（指令、数据、堆栈）。
*   内核状态，包括：
    *   进程ID (PID)。
    *   进程状态（例如，正在运行、等待中）。
    *   打开的文件描述符表。
    *   指向父进程的指针。

在xv6中，每个进程的状态由 `struct proc`（在 `kernel/proc.h` 中定义）来描述。xv6使用一个固定的 `proc` 数组来管理所有进程。

### xv6进程状态

xv6中的进程可以处于以下几种状态之一：
*   `UNUSED`：`proc` 结构体是空闲的，可以被分配给一个新进程。
*   `USED`：进程已被分配，但尚未完成初始化。
*   `SLEEPING`：进程正在等待某个事件（例如，I/O操作完成或 `wait()` 调用结束）。它不会被调度执行。
*   `RUNNABLE`：进程已准备好运行，正在等待CPU时间。调度器会从处于此状态的进程中选择一个来运行。
*   `RUNNING`：进程当前正在CPU上执行。
*   `ZOMBIE`：进程已经执行完毕 (`exit()`)，但其父进程还没有通过 `wait()` 来回收它。僵尸进程保留了PID和退出状态，以便父进程可以查询。

## 进程生命周期

### 创建进程: `fork()`

`fork()` 是UNIX系统中创建新进程的主要方式。
*   它会创建一个调用进程的精确副本，这个新进程被称为**子进程**。
*   父进程和子进程拥有各自独立的内存空间。对其中一个内存的修改不会影响另一个。
*   内核会复制父进程的所有状态，包括指令、数据、寄存器、文件描述符和当前工作目录。
*   `fork()` 的巧妙之处在于它在父子进程中的返回值不同：
    *   在**父进程**中，`fork()` 返回新创建子进程的PID。
    *   在**子进程**中，`fork()` 返回 `0`。
    *   如果出错，则返回 `-1`。

这种设计允许程序在 `fork()` 之后，通过检查返回值来区分父子进程，并执行不同的代码路径。

**示例 (`ex3.c`):**
```c
#include "kernel/types.h"
#include "user/user.h"

int main() {
  int pid = fork();
  if (pid > 0) {
    printf("parent: child=%d\n", pid);
  } else if (pid == 0) {
    printf("child: exiting\n");
    exit(0);
  } else {
    printf("fork error\n");
  }
  wait(0);
  return 0;
}
```
在这个例子中，父进程和子进程都会从 `fork()` 返回后继续执行。父进程打印出子进程的PID，而子进程打印一条消息然后退出。

### 运行新程序: `exec()`

`fork()` 创建了父进程的副本，但如果我们想运行一个全新的程序怎么办？这时就需要 `exec()`。

`exec()` 系统调用用一个全新的程序来替换当前进程的内存和寄存器。
*   它会从指定的可执行文件中加载指令和数据。
*   旧的内存空间被完全丢弃。
*   文件描述符默认是保留的，这为I/O重定向提供了便利。
*   如果 `exec()` 调用成功，它**永远不会返回**，因为调用它的程序已经被新程序替换了。

**Shell如何运行命令**

Shell（如 `sh`）是 `fork()` 和 `exec()` 组合使用的经典例子。当你输入一个命令（如 `ls`）时，Shell会：
1.  调用 `fork()` 创建一个子进程。
2.  在子进程中，调用 `exec("ls", ...)` 来加载并运行 `ls` 程序。
3.  在父进程（也就是Shell本身）中，调用 `wait()` 等待子进程（`ls` 命令）执行完毕。
4.  子进程结束后，`wait()` 返回，Shell打印下一个提示符，等待新命令。

这个模型非常强大，因为它将命令执行与Shell本身隔离开来，并且允许进行I/O重定向等操作。

### 进程终止: `exit()` 和 `wait()`

*   **`exit(status)`**：当一个进程完成工作后，它会调用 `exit()` 来终止自己。`status` 参数是一个整数，用于告知父进程它的退出状态（通常 `0` 表示成功）。调用 `exit()` 后，进程会进入 `ZOMBIE` 状态，释放大部分资源，但保留PID和退出状态，直到父进程来“认领”。

*   **`wait(&status)`**：一个父进程可以通过调用 `wait()` 来等待其任何一个子进程退出。
    *   如果父进程有子进程处于 `ZOMBIE` 状态，`wait()` 会立即返回其中一个僵尸子进程的PID，并通过指针参数带回其退出状态。同时，内核会彻底清理这个僵尸子进程。
    *   如果父进程有子进程在运行但没有僵尸子进程，`wait()` 会进入 `SLEEPING` 状态，直到某个子进程退出。
    *   如果父进程没有任何子进程，`wait()` 会立即返回 `-1`。

### `init` 进程

`init` 是系统创建的第一个用户进程。它在系统中扮演着特殊的角色：
*   它会循环调用 `wait()`，负责回收所有**孤儿进程**（即父进程先于子进程退出的进程）。
*   如果一个进程的父进程退出了，内核会自动将这个进程的父进程指针指向 `init` 进程。这样可以确保系统中的所有进程最终都能被正确回收，避免僵尸进程永远存在。

