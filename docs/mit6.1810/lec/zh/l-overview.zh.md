---
title: 第1讲：操作系统概述
---
 
6.1810 2024 第1讲：操作系统概述

概述

* 什么是操作系统？
  [用户/内核图]
  - 硬件：CPU、内存、磁盘、网络等
  - 用户应用程序：sh、cc、数据库等
  - 内核服务：文件系统、进程、内存、网络等
  - 系统调用

* 操作系统的目的是什么？
  - 在多个应用程序之间复用硬件
  - 隔离应用程序以确保安全并控制错误
  - 在协作的应用程序之间共享数据
  - 为可移植性和便利性抽象硬件

* 设计上的矛盾使得操作系统设计变得有趣
  - 高效 vs. 抽象/可移植/通用
  - 强大的接口 vs. 简单的接口
  - 灵活 vs. 安全
  - 可移植 vs. 利用新硬件和接口

* 如果你... 你会很高兴你选了这门课
  * 对计算机系统如何工作感到好奇
  * 需要追踪错误或安全问题
  * 关心高性能

课程结构

* 在线课程信息：
  网站 -- 课程表、作业、实验
    https://pdos.csail.mit.edu/6.1810/
    或用谷歌搜索 -- 所有材料都是公开的
  Piazza -- 公告、讨论、实验帮助

* 课程
  * 操作系统思想
  * xv6（一个小操作系统）的案例研究，通过代码和 xv6 手册
  * 实验背景
  * 操作系统论文
  * 在课前提交关于每次阅读的问题。

* 实验：
  重点：动手实践经验
  大多每个实验为期一周。
  三种类型：
    系统编程（下周截止...）
    操作系统原语，例如线程切换。
    xv6 的操作系统内核扩展，例如网络。
  寻求帮助：
    在 Piazza 上提问和回答问题
    参加助教的答疑时间
  讨论很棒，但请不要看别人的解决方案！

* 评分：
  50% 实验，基于测试（你运行的相同测试）。
  30% 考试 -- 期中、期末。
  15% 实验检查会议：我们会随机选择实验向你提问。
  5% 家庭作业问题
  课程成绩大部分来自实验。请尽早开始！

UNIX 系统调用简介

* 应用程序通过“系统调用”与操作系统交互。
  你将在第一个实验中使用系统调用。
  并在后续实验中扩展和改进它们。

* 我将展示一些应用程序示例，并在 xv6 上运行它们。
  xv6 是我们专门为这门课创建的一个操作系统。
  xv6 模仿 UNIX，但简单得多。
  为什么是 UNIX？
    它是当今许多操作系统的祖先。
    例如 Linux 和 MacOS。
    学习 xv6 将帮助你理解许多其他操作系统。
  你将能够消化所有 xv6 -- 没有神秘之处。
    附带的书解释了 xv6 的工作原理及其原因
  xv6 在 6.1810 中有两个角色：
    核心机制的例子
    大多数实验的起点
  xv6 运行在 RISC-V CPU 上，就像 6.1910 (6.004) 中一样
  你将在 qemu 机器模拟器中运行 xv6

* 示例：ex1.c，将输入复制到输出
  从输入读取字节，将它们写入输出
  % make qemu
  $ ex1
  你可以通过网站上的课程表找到这些示例程序
  ex1.c 是用 C 语言编写的
    C 可能是操作系统内核最常用的语言
  read() 和 write() 是系统调用
    它们看起来像函数调用，但实际上会跳转到内核中。
    以一种保持用户/内核隔离的方式。
  read()/write() 的第一个参数是“文件描述符”（FD）
    传递给内核，告诉它要读/写哪个“打开的文件”
    一个 FD 连接到一个文件/管道/套接字等
    该 FD 必须事先已经打开
    一个进程可以打开许多文件，拥有许多 FD
  UNIX 约定：fd 0 是“标准输入”，1 是“标准输出”
    程序不必知道输入来自哪里，或输出到哪里
    它们可以只读/写 FD 0 和 1
  read() 的第二个参数是要读入的内存地址
  第三个参数是要读取的字节数
    read() 可能读取的更少，但不会更多
  返回值：实际读取的字节数，或 -1 表示错误
  read()/write() 不关心数据的格式
    UNIX I/O 是 8 位字节
    解释是特定于应用程序的，例如数据库记录、C 源代码等
  文件描述符从哪里来？

* 示例：ex2.c，创建一个文件
  open() 创建（或打开）一个文件，返回一个文件描述符（或 -1 表示错误）
  FD 是一个小整数
  FD 索引到由内核维护的每个进程的表中
  [用户/内核图]
  $ ex2
  $ cat out
  不同的进程有不同的 FD 命名空间
    所以 FD 3 对不同的进程通常意味着不同的东西
  这些例子忽略了错误 -- 不要这么草率！
  xv6 手册中的图 1.2 列出了系统调用
    或者查看 UNIX 手册页，例如 "man 2 open"

* 当程序调用像 open() 或 write() 这样的系统调用时会发生什么？
  看起来像一个函数调用，但它实际上是一条特殊指令
    CPU 保存一些用户寄存器
    CPU 提高特权级别
    CPU 跳转到内核中一个已知的“入口点”
  现在在内核中运行 C 代码
  内核调用系统调用实现
    sys_open() 在文件系统中查找名称
    它可能会等待磁盘
    它更新内核数据结构（文件块缓存、FD 表）
  恢复用户寄存器
  降低特权级别
  跳回到程序中的调用点，程序继续执行
  我们将在课程后面看到更多细节

* 我一直在向 UNIX 的命令行界面——shell——输入命令。
  shell 打印“$”提示符。
  shell 是一个普通的用户程序，不是内核的一部分。
  shell 让你运行 UNIX 命令行工具
    用于系统管理、处理文件、开发、编写脚本
    $ ls
    $ ls > out
    $ grep x < out
  UNIX 也支持其他交互方式
    图形用户界面、服务器、路由器等。
  但通过 shell 进行分时是 UNIX 最初的重点。

* 示例：ex3.c，创建一个新进程
  你输入的每个命令，shell 都会为其创建一个新进程
    进程是一个正在运行的程序，有内存、堆栈、内核状态
    与其他进程隔离以控制错误
  ex3.c
  fork() 系统调用创建一个新进程
  内核复制调用进程
    指令、数据、寄存器、文件描述符、当前目录
    “父”进程和“子”进程
  [图：ex3 和子进程]
  所以子进程和父进程最初是相同的！
    除了：fork() 在父进程中返回一个 pid，在子进程中返回 0
  pid（进程 ID）是一个整数；内核为每个进程分配一个不同的 pid
  $ ex3
  因此：
    ex3.c 的 "fork() returned" 在*两个*进程中都执行
    "if(pid == 0)" 允许代码知道自己是父进程还是子进程
    fork 之后两个进程都运行
  好的，fork() 让我们创建一个新进程
    我们如何在该进程中运行一个程序？

* 示例：ex4.c，用可执行文件替换调用进程
  shell 如何运行一个程序，例如
    $ echo a b c
  程序存储在一个文件中：指令和初始内存
    由编译器和链接器创建
  所以有一个名为 echo 的文件，包含指令
    在你自己的电脑上：ls -l /bin/echo
  ex4.c
  exec() 用一个可执行文件替换当前进程
    丢弃旧的指令和数据内存
    从文件中加载指令和初始内存
    保留文件描述符
  $ ex4
  exec(文件名, 参数数组)
    参数数组包含命令行参数；exec 将其传递给 main()
    cat user/echo.c
    echo.c 展示了程序如何查看其命令行参数
  如果成功，exec() 不会返回！

* 示例：ex5.c，fork() 一个新进程，exec() 一个程序
  shell 不能简单地调用 exec()！
    因为它将不再运行
    将无法接受多个命令
  ex5.c 展示了 shell 如何处理这个问题：
    fork() 一个子进程
    子进程调用 exec()
    父进程 wait() 等待子进程结束
  $ ex5
  你输入的每个命令，shell 都会执行这个 fork/exec/wait 过程
    wait() 之后，shell 打印下一个提示符
  exit(status) -> wait(&status)
    status 允许子进程向父进程传回 32 位信息
    status 约定：0 = 成功，1 = 命令遇到错误
  注意：fork() 复制，但 exec() 丢弃了复制的内存
    这可能看起来很浪费
    你将在“写时复制”实验中消除这种浪费

* 示例：ex6.c，重定向命令的输出
  shell 是如何做到这一点的？
    $ echo hello > out
  答案：fork，子进程更改 FD 1，子进程 exec echo
  $ ex6
  $ cat out
  注意：open() 总是选择最低的未使用 FD；由于 close(1)，这里是 1。
  注意：exec 保留 FD
  fork、FD 和 exec 很好地结合在一起，实现了 I/O 重定向
    先 fork 再 exec 的分离让子进程有机会更改 FD
      在 exec() 放弃控制之前
      并且不干扰父进程的 FD
  FD 提供了间接性
    命令只使用 FD 0 和 1，不必知道它们去向何方
  因此：只有 sh 知道 I/O 重定向，而不是每个程序

* 关于设计决策，值得问“为什么”：
  为什么是这些 I/O 和进程抽象？为什么不是别的？
  为什么要提供文件系统？为什么不让程序以自己的方式使用磁盘？
  为什么是 FD？为什么不把文件名传递给 write()？
  为什么不把 fork() 和 exec() 合并起来？
  UNIX 运行得很好，但还有其他好的设计！

* 示例：ex7.c，通过管道通信
  shell 如何实现
    $ ls | grep x
  一个 FD 可以指向一个“管道”，而不是一个文件
  pipe() 系统调用创建两个 FD
    从第一个 FD 读取
    向第二个 FD 写入
  内核为每个管道维护一个缓冲区
    [用户/内核图]
    write() 追加到缓冲区
    read() 等待直到有数据
  $ ex7

* 示例：ex8.c，进程间通信
  管道与 fork() 结合，允许父/子进程通信
    创建一个管道，
    fork，
    父进程写入一个管道 fd，
    子进程从另一个读取。
    [图]
  $ ex8
  shell 通过两次 fork 和调用 exec() 来构建管道
  管道是一个独立的抽象，但与 fork() 结合得很好

* 示例：ex9.c，列出目录中的文件
  ls 如何获取目录中的文件列表？
  你可以打开一个目录并读取它 -> 文件名
  “.” 是进程当前目录的伪名称
  $ ex9
  更多细节请参见 ls.c

* 下周
  - 更多关于这类程序执行时会发生什么
  - 更多关于 C 编程
  - 第一个实验下周四截止，你将使用这些系统调用
