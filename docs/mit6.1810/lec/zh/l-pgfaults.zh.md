---
title: 第16讲：页错误
---

6.1810 2024 第7讲：页错误

* **本讲计划：** 你可以用虚拟内存做的很酷的事情
  - 更好的性能/效率
    - 例如，一个零填充页
    - 例如，写时复制 fork
  - 为应用程序员提供便利
    - 例如，惰性分配
    - 例如，内存映射文件

* **虚拟内存：几种观点**
  * **主要目的：隔离**
    - 每个进程都有自己的地址空间
  * **虚拟内存提供了一个间接层**
    - 为内核提供了做酷炫事情的机会
    - 已有的一些例子：
      - 共享的 trampoline 页
      - 保护页 (guard page)
      - upid
      - 超级页 (super pages)
    - 但还有更多可能...

* **关键思想：在页错误时更改页表**
  - 页错误是陷阱的一种形式（就像系统调用一样）
  - Xv6 在页错误时会 panic
    - 但你不必 panic！
  - 相反：
    - 更新页表而不是 panic
    - 重启指令（参见陷阱讲座中的 `userret()`）
  - 页错误和更新页表的组合非常强大！

* **RISC-V 页错误**
  - 16种异常中有3种与分页有关
  - 异常导致受控地转移到内核
    - 参见陷阱讲座

* **在页错误时我们可能需要的信息来做一些有趣的事情：**
  1. **导致错误的虚拟地址**
     - 查看 `stval` 寄存器；页错误会将其设置为错误地址
  2. **导致错误的违规类型**
     - 查看 `scause` 寄存器值（指令、加载和存储页错误）
  3. **发生错误的指令和模式**
     - 用户指令指针 (IP): `tf->epc`
     - 用户/内核模式：在 `usertrap`/`kerneltrap` 中是隐式的

* **惰性/按需页面分配**
  * **xv6 用户地址空间 (图 3-4)**
    - `sbrk()` 增长堆
  * **`sbrk()` 是老式的；**
    - 应用程序通常会请求它们需要的内存
    - 例如，为可能的最大输入分配，但应用程序通常会使用更少
    - 如果它们请求很多，`sbrk()` 可能会很昂贵
      - 例如，如果所有内存都在使用中，必须等到内核驱逐一些页面以释放内存
    - `sbrk` 分配的内存可能永远不会被使用。
  * **现代操作系统惰性地分配内存**
    - **计划：**
      - 在应用程序需要时分配物理内存
      - 在 `sbrk` 时调整 `p->sz`，但不分配
      - 当应用程序使用该内存时，将导致页错误
      - 在页错误时分配内存
      - 在错误指令处恢复
    - **可能使用更少的内存**
      - 如果未使用，则无错误，无分配
    - **将分配的成本分散到页错误中，而不是在 `sbrk()` 中预先支付**

* **演示：用户页表和惰性分配**
  * **sh 的用户页表**
    - 在 `exec.c` 的 `exec()` 中构建
    - 注意它与内核不同 —— 例如，没有 UART 等
    - 文本、数据、保护页、堆栈
    - 树状视图
      - 加载和堆栈后打印页表
    - 导致页错误（例如，写入堆栈页）
      - 查看 `stval`, `cause`, 和 `epc`

  * **应用程序如何为其堆分配更多内存？**
    - `sbrk(n)` -- 一个系统调用
      - 由 sh 的 `malloc()` 调用以分配更多堆空间
      - **急切地**分配内存
        - `sysproc.c` `sys_sbrk()`
        - `proc.c` `growproc()`
        - `vm.c` `uvmalloc()` -- 为每个新页
        - `kalloc()` 获取用于用户堆的 RAM 的物理地址
        - `mappages()`
      - 它正在修改进程的用户页表
      - 此刻它不是活动的，因为我们在内核中
      - 即，`satp` 指向内核页表

  * **惰性分配**
    - 修改 `sysproc.c`
    - 运行 `ls` 并 panic
      - 查看 `scause`, `stval`, 和 `sepc`
    - 查看 `sh.c`, `umalloc.c`
    - 修改 `trap.c`
    - 修改 `vm.c`
      - `vmfault`, `ismapped`, `uvmunmap`
    - 使其真实需要更多细节
      - `copyin`/`copyout`, `uvmcopy`, 检查无效地址等。

  * **运行 `top` 和 `vmstat`**

* **一个零填充页（按需零填充）**
  * 应用程序通常有大量内存必须为零
    - 全局数组等。
    - “块起始符号” (bbs) 段
  * 因此，内核必须经常用零填充一个页面
  * **想法：** `memset` *一个* 页面为零
    - 当内核需要零填充页时，写时复制映射该页
    - 写入时，制作页的副本并将其读/写映射到应用程序地址空间

* **写时复制 fork (copy-on-write fork)**
  * **观察：**
    - xv6 `fork` 从父进程复制所有页面（见 `fork()`）
    - 但 `fork` 通常紧接着是 `exec`
  * **想法：** 在父子之间共享地址空间
    - 修改 `fork()` 以写时复制方式映射页面
      - 在 PTE 中使用额外的可用系统位 (RSW)
    - 在页错误时，制作页的副本并将其读/写映射
    - 需要对物理页面进行引用计数
    - 在 xv6 中很容易，但在真实操作系统中可能具有挑战性
      - 例如，参见 https://lwn.net/Articles/849638/

* **按需分页 (demand paging)**
  * **观察：** `exec` 将整个文件加载到内存中（见 `exec.c`）
    - 昂贵：这样做需要时间（例如，文件存储在慢速磁盘上）
    - 不必要：可能不会使用整个文件
  * **想法：** 按需从文件加载页面
    - 分配页表条目，但将它们标记为按需
    - 发生错误时，从文件中读入页面并更新页表条目
    - 需要保留一些关于页面在磁盘上位置的元信息
      - 此信息通常在称为虚拟内存区域 (VMA) 的结构中
  * **挑战：** 文件大于物理内存（见下一个想法）

* **使用大于物理内存的虚拟内存**
  * **观察：** 应用程序可能需要比物理内存更多的内存
  * **想法：** 将地址空间中不常用的部分存储在磁盘上
    - 透明地换入和换出地址空间的页面
    - 不写出未被修改的页面
      - PTE 中的 D(irty) 位对此有帮助
  * **当工作集适合物理内存时有效**
    - 最流行的替换策略：最近最少使用 (LRU)
    - PTE 中的 A(ccess) 位帮助内核实现 LRU
  * **替换策略是操作系统文献中的巨大主题**
    - 许多操作系统允许应用程序影响其决策（例如，使用 `madvise` 和 `mlock`）。
  * **演示：** 运行 `top` 和 `vmstat`
    - 在笔记本电脑和 dialup.athena.mit.edu 上
    - 查看 VIRT RES MEM SHR 列

* **内存映射文件**
  * **想法：** 允许使用加载和存储访问文件
    - 可以轻松地读写文件的一部分
    - 例如，不必使用 `lseek` 系统调用更改偏移量
  * **Unix 系统为内存映射文件提供了一个新的系统调用：**
    - `void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`
  * **内核按需换入文件的页面**
    - 当内存已满时，换出不常用的文件页面

* **用于用户应用程序的页错误**
  * 许多使用页错误的有用内核技巧
    - 也允许用户应用程序使用这些技巧
  * **linux: `mmap` 和 `sigaction`**
  * https://pdos.csail.mit.edu/6.828/2018/homework/mmap.html
  * 参见本学期后面的 appel&li 论文

* **虚拟内存仍在发展**
  - Linux 中最近的一些变化
    - PKTI 处理 meltdown 侧信道
      - (https://en.wikipedia.org/wiki/Kernel_page-table_isolation)
    - xv6 基本上实现了 KPTI
  - 较近的变化
    - 支持 5 级页表（57 个地址位！）
    - 支持 ASID
  - 更早的变化
    - 支持大页面
    - NX (No eXecute) PTE_X 标志

* **总结**
  - 分页加上页表提供了一个强大的间接层
  - 你将实现 COW 和内存映射文件
  - xv6 很简单，但你有足够的信息来推断
