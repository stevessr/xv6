---
title: 第13讲：设备驱动与中断
---

6.1810 2024 第9讲：设备驱动与中断

**主题：设备驱动**
- CPU 需要连接设备：存储、通信、显示等
  - 操作系统设备驱动程序控制这些设备
- 设备处理可能很困难：
  - 设备通常有僵化且复杂的接口
  - 设备和 CPU 并行运行 —— 并发
  - 中断
    - 硬件现在需要关注！
      - 例如，数据包到达
    - 软件必须搁置当前工作并做出响应
      - 在 RISC-V 上，使用与系统调用和异常相同的陷阱机制
    - 中断可能在不合时宜的时候到达
- 生产内核中的大多数代码都是设备驱动程序
  - 你将为网卡编写一个

**设备在哪里？**
- [CPU, 总线, 内存, 磁盘, 网络, uart]

**编程设备：内存映射 I/O**
- 设备硬件有一些控制和状态寄存器
- 设备寄存器位于一个物理“内存”地址
- 对这些地址的加载/存储操作会读/写设备控制寄存器
- 平台设计者决定设备在物理地址空间中的位置

**示例设备：UART**
- 通用异步收发器 (Universal Asynchronous Receiver Transmitter)
- 串行接口，输入和输出
- “RS232 端口”，例如 qemu 控制台
- uart 是硬件 —— 晶体管
- qemu 模拟了常见的 16550 uart 芯片
  - 数据手册：课程表页面上的 16550.pdf 链接，或网络搜索
  - 数据手册详细说明了物理、电气和编程
- [rx 线, 接收移位寄存器, 接收 FIFO]
- [发送 FIFO, 发送移位寄存器, tx 线]
- 16 字节的 FIFO
- 内存映射的 8 位寄存器，位于物理地址 UART0=0x10000000：
  - (16550.pdf 第9页)
  - 0: RHR / THR -- 接收/发送保持寄存器
  - 1: IER -- 中断使能寄存器, 0x1 是接收使能, 0x2 是发送使能
  - ...
  - 5: LSR -- 线路状态寄存器, 0x1 是接收数据就绪

**内核设备驱动程序如何使用这些寄存器？**
- 简单示例：`kernel/uart.c` 中的 `uartgetc()`
- `ReadReg(RHR)` 变成了 `*(char*)(0x10000000 + 0)`

**为什么 UART 有 FIFO 缓冲区？**

**设备驱动程序必须处理设备未就绪的情况**
- `read()` 但 rx FIFO 为空
- `write()` 但 tx FIFO 已满
- LSR 位：数据就绪 (Data Ready), 发送器空 (Transmitter Empty)

**设备驱动程序应该如何等待？**

也许是“忙循环”：
```c
while((LSR & 1) == 0)
  ;
return RHR
```
- 如果等待的可能性不大 —— 如果输入几乎总是可用，那就可以
- 但对于控制台来说太浪费了！
  - FIFO 中通常没有等待的输入（按键）
  - 许多设备都是这样 —— 可能需要等待很长时间的 I/O

**解决方案：中断**
- 当设备需要驱动程序关注时，设备会引发一个中断
- UART 在以下情况会中断：
  - rx FIFO 从空变为非空，或
  - tx FIFO 从满变为不满

**内核如何看到中断？**
- [在图表中添加 PLIC，包括总线]
- 设备 -> PLIC -> CPU -> 陷阱 -> `usertrap()`/`kerneltrap()` -> `devintr()`
- `trap.c` `devintr()`
- `scause` 的高位表示陷阱来自设备中断
- 一个 PLIC 寄存器指示哪个设备中断了
  - “IRQ” -- UART 的 IRQ 是 10
  - IRQ 由平台定义 —— 在本例中是 qemu

**中断通常只是设备状态可能已更改的提示**
- 真正的情况在设备的状态寄存器中
  - 设备驱动程序必须读取它们来决定采取什么行动（如果有的话）
- 对于 UART，检查 LSR 以查看 rx FIFO 是否非空，tx FIFO 是否不满
  - 如 `uartgetc()` 中所示
  - 一个中断可能表示需要多个操作

**让我们看看 xv6 如何设置中断机制**
- `start()` `start.c:35`
  - `w_sie(r_sie() | SIE_SEIE | SIE_STIE);`
  - 请求来自 PLIC 和计时器的中断
- `uartinit()` `uart.c:75`
  - `WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);`
- `trap()` `trap.c:65` 调用
  - `intr_on()` `riscv.h:285`
    - `w_sstatus(r_sstatus() | SSTATUS_SIE);`

**让我们看看 shell 从控制台/UART 读取输入**
```
% make qemu-gdb
% gdb
(gdb) c
(gdb) tbreak sys_read
(gdb) c
<press return>
(gdb) tui enable
(gdb) where
sys_read()
  fileread()
    consoleread()
      查看 cons.buf, cons.r, cons.w -- “生产者/消费者缓冲区”
      [图：buf, r, w]
      (gdb) print cons
      还没有可读的内容...
      sleep()
```

**现在让我们看看 uart 中断处理**
我将按回车键

**问：我应该告诉 gdb 在哪里设置断点以查看中断？**

```
(gdb) tb *kernelvec
(gdb) c
<press return>
```

**我们是怎么到这里的？**
- `(gdb) where`
- 在内核中；没有进程在运行；`scheduler()`
- UART -> PLIC -> `stvec` -> `kernelvec`
- `(gdb) p/x $stvec`
- `(gdb) p $pc`

**`kernelvec.S`:**
- 如果一个进程在用户空间执行，陷阱会
  - 转到 `trampoline` 和 `usertrap()`，我们已经看过了
- `kernelvec` 类似于 `trampoline`，但用于内核执行时的陷阱
- 在当前堆栈上保存寄存器；哪个堆栈？
  - 在这种情况下，是特殊的调度器堆栈
  - 如果在内核中执行系统调用，则是某个进程的内核堆栈
- 如果在内核中，并且中断已启用，则堆栈保证有效
- `kernelvec` 最后跳转到 `kerneltrap()` -- C 代码

```
(gdb) tb kerneltrap
(gdb) c
(gdb) next ... into devintr()
  devintr()
    (gdb) p/x $scause
    scause 的高位意味着它是一个中断
      riscv 特权手册第96页/表22
    plic_claim() 找到 IRQ (哪个设备)
    (gdb) p irq
      PLIC 为 UART 生成 IRQ 10
    uartintr()
      uartgetc()
      LSR 中有什么？
        (gdb) x/1bx 0x10000005
        16550.pdf 第9页说低位是数据就绪
      如果 LSR 说数据就绪，从 RHR 获取
      x/1bx 0x10000005 -- 注意低位不再被设置
      consoleintr()
        退格/换行等处理
        print cons
        x/3b cons.buf
        wakeup()
通过 devintr, plic_complete(), kerneltrap 返回
```

**调度器现在将恢复 sh 的 `read()` 系统调用**
- 因为被唤醒了
- 让我们在 sh 的 `consoleread()` 中设置断点
```
(gdb) tb console.c:99
(gdb) c
(gdb) where
consoleread() 的 sleep() 返回
consoleread() 在 cons.buf[cons.r] 中看到我们的字符
sh 的 read 返回，带着我输入的换行符
```

**通用设备驱动程序模式：上半部分和下半部分**
- [图：上半部分/下半部分]
- **上半部分：**
  - 执行进程的系统调用，例如 `write()` 或 `read()`
  - 可能告诉设备开始输出或输入
  - 可能等待输入就绪，或输出完成
- **共享信息（缓冲区）**
- **下半部分：**
  - 中断处理程序
  - 从/向设备硬件读取输入，或发送更多输出
  - 与“上半部分”进程交互
    - 将输入放在上半部分可以找到的地方
    - 告诉上半部分输入已到达
    - 或者可以发送更多输出
  - *不* 在上半部分进程的上下文中运行
    - 可能在不同的核心上
    - 可能中断了某个其他进程
  - 所以交互必须是保持距离的 —— 缓冲区、`sleep`/`wakeup`

**如果多个设备想同时中断怎么办？**
- PLIC 在核心之间分配中断
  - 不同的中断可以在不同的核心上并行处理
- 每个中断由第一个调用 `plic_claim()` 的核心声明
- 每个单独的设备最多只有一个中断在进行中
  - PLIC 通过 `plic_complete()` 知道完成

**如果内核在设备请求中断时禁用了中断怎么办？**
- 通过在 `sstatus` 中清除 `SIE`，使用 `intr_off()`
- PLIC/CPU 记住挂起的中断
- 当内核重新启用中断时传递

**中断涉及多种形式的并发**
1.  设备在内核消耗时产生新数据
    - 或者反过来
2.  如果启用，设备中断可能在任何时候发生！
    - 例如，当上半部分正在执行时
3.  中断可能与上半部分在不同的 CPU 上并行运行
    - 锁：下一讲

**解耦生产和消费**
- **来自设备的输入：**
  - 可能在读取器未等待时到达
  - 可能比读取器能读取的速度更快或更慢
  - 希望为了效率批量累积输入和 `read()`
- **向设备的输出：**
  - 如果设备慢，希望缓冲输出以便进程可以继续
  - 如果设备快，希望为了效率批量发送
- **一个常见的解决方案模式**
  - 生产者/消费者缓冲区
  - 生产者和消费者的独立指针
  - 等待；通知；
- 我们已经在两个层面上看到了这一点：
  - UART 内部 FIFO，用于设备和驱动程序 —— 加上中断
  - `cons.buf`，用于上半部分和下半部分 —— 加上 `sleep`/`wakeup`
- 我们在看管道时会再次看到这一点

**如果启用，设备中断可能在任何两条指令之间发生**
- **示例：**
  - 假设内核正在一个全局变量 `n` 中计数
  - 上半部分：`n = n + 1`
  - 中断下半部分：`n = n + 1`
  - `n=n+1` 的机器代码如下：
    ```assembly
    lw a4, n
    add a4, a4, 1
    sw a4, n
    ```
  - 如果在 `lw` 和 `add` 之间发生中断怎么办？
    - 并且中断处理程序也说 `n = n + 1`？
- **一个解决方案：** 在上半部分短暂禁用中断
  ```c
  intr_off()
  n = n + 1
  intr_on()
  ```
  - `intr_off()`: `w_sstatus(r_sstatus() & ~SSTATUS_SIE);`
- 很好，但还不够：中断可能在不同的 CPU 上到达
  - 我们看锁的时候会更多地讨论这个

**中断会产生开销**
- 大约一微秒
- CPU 陷阱、保存寄存器、决定哪个
  - 设备，以及稍后恢复寄存器和返回所需的时间
- “开销” == 成本 *不包括* 有用的设备驱动程序工作

**如果中断率很高怎么办？**
- 示例：现代以太网每秒可以传递数百万个数据包
- 以该速率，CPU 时间的很大一部分用于中断*开销*

**轮询：高频率事件通知策略**
- 告诉设备（或 PLIC）不要为该设备生成中断
- 上半部分循环直到设备表示已就绪
  - 例如 `uartputc_sync()`
  - 或者可能在一些频繁执行的内核代码中检查，例如 `scheduler()`
- 然后处理自上次轮询以来累积的所有内容
- 如果设备通常很快就绪，比中断更有效
- 也许根据测量的速率切换策略

**DMA (直接内存访问) 可以高效地移动数据**
- xv6 uart 驱动程序在软件中一次读取一个字节
  - CPU 对此效率不高：
    - 芯片外，不可缓存，一次 8 位
  - 仅适用于低速设备
- 大多数快速设备自动将输入批次复制到 RAM —— DMA
  - 然后中断
  - 输入已经在普通 RAM 中
  - CPU RAM 操作是高效的

**中断的演变**
- 中断开销过去是几个 CPU 周期
  - 现在是 1000 个周期 —— 大约一微秒
    - 不包括实际的设备驱动程序代码
  - 由于流水线、大寄存器集、缓存/TLB 未命中、慢速 RAM
- 所以：
  - 旧方法：简单的硬件，智能的软件，大量的中断
  - 新方法：智能的硬件，为每个中断做大量工作

**中断和设备处理是一个持续关注的领域**
- 特殊的快速中断处理程序路径
- 在 CPU 之间巧妙地分配工作
- 将中断转发到用户空间
  - 用于页错误和用户处理的设备
  - 硬件直接传递给用户，无需内核干预？
  - 通过内核的更快转发路径？
- 我们将在本课程的后面看到这些主题
