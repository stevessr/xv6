# 实验指南：使用超级页面

本指南涵盖页表实验的第二个，也是更高级的任务：修改 xv6 以便为大块内存分配使用 2MB 的超级页面（megapages）。

---

## 目标

本任务的目标是增强内核的内存管理能力，使其能够使用单个一级页表条目（PTE）来映射一个 2MB 的物理内存区域，而不是使用 512 个二级页表条目。这应该在进程通过 `sbrk()` 请求一块足够大且对齐的内存时发生。

## 实现思路

这是一个复杂的任务，涉及对整个内存管理系统的修改。提供完整的代码解决方案会很长，因此本指南提供一个高层次的策略。

### 1. 定义超级页面常量

首先，在 `kernel/riscv.h` 中定义与超级页面相关的常量，以便在整个内核中使用。

**文件: `kernel/riscv.h`**
```diff
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -3,6 +3,8 @@
 #define PGSIZE 4096 // bytes per page
 #define PGSHIFT 12  // bits of offset within a page
 #define PGMASK (PGSIZE - 1)
+#define MEGAPAGE_SIZE (2 * 1024 * 1024) // 2MB
+#define MEGAPAGE_SHIFT 21 // 2^21 = 2MB
 
 #define KERNBASE 0x80000000L
 #define PHYSTOP (KERNBASE + 128*1024*1024)

```

### 2. 实现超级页面物理内存分配器

您需要一种方法来分配和释放 2MB 对齐的物理内存块。一个简单的方法是在 `kernel/kalloc.c` 中为此创建一个专用的分配器。

**文件: `kernel/kalloc.c`**
1.  **数据结构:** 为超级页面的空闲列表定义一个 `struct` 和一个用于保护它的锁。
2.  **`kinit()`:** 在 `kinit()` 中，在用 `freerange` 初始化主 4KB 页面分配器之前，为超级页面预留一部分物理内存。以 2MB 为单位遍历这块预留内存，并通过调用您新的 `superfree()` 函数将它们添加到您的超级页面空闲列表中。
3.  **`superalloc()`:** 此函数应获取锁，从空闲列表中弹出一个 2MB 的块，释放锁，并返回该块的地址。
4.  **`superfree()`:** 此函数应获取锁，将被提供的 2MB 块添加回空闲列表，并释放锁。
5.  **`defs.h`:** 将 `superalloc()` 和 `superfree()` 的原型添加到 `kernel/defs.h`。

### 3. 修改 `vm.c` 中的核心虚存函数

这是最复杂的部分。`uvmalloc`、`uvmunmap` 和 `uvmcopy` 都必须能够感知超级页面。

*   **`uvmalloc` (在 `proc.c` -> `growproc` -> `uvmalloc`):**
    *   分配内存时，检查当前虚拟地址是否是 2MB 对齐的，并且分配大小是否至少为 2MB。
    *   如果是，则尝试使用 `superalloc()` 分配一个 2MB 的物理块。
    *   如果成功，您必须手动遍历页表到该虚拟地址的一级 PTE。如果一级页表页不存在，您需要分配它。
    *   将一级 PTE 设置为指向该 2MB 物理块的叶子条目。通过设置 `PTE_R`、`PTE_W` 或 `PTE_X` 中的任意一位，一个非叶子 PTE 就会变成叶子（从而成为超级页面）。
    *   成功映射一个超级页面后，将分配循环的计数器增加 2MB。

*   **`uvmunmap`:**
    *   此函数必须能够检测并释放超级页面。
    *   取消映射一个虚拟地址时，您必须手动遍历页表以检查该地址是否属于一个超级页面。您可以通过检查一级 PTE 来做到这一点。如果它是一个有效的叶子 PTE，那么您就找到了一个超级页面。
    *   如果找到了超级页面，对关联的物理地址调用 `superfree()` 并清除一级 PTE。
    *   循环计数器必须相应地增加 2MB。

*   **`uvmcopy` (用于 `fork()`):**
    *   当进程 `fork` 时，`uvmcopy` 必须能正确地复制超级页面映射。
    *   它需要遍历父进程的页表并检查一级页表中的超级页面条目。
    *   如果找到超级页面，它必须：
        1.  使用 `superalloc()` 为子进程分配一个新的 2MB 块。
        2.  将父进程物理块的全部 2MB 数据复制到子进程的新块中。
        3.  在子进程的页表中将新块映射为超级页面。
    *   复制循环的计数器应相应地增加 2MB。

这个任务需要对页表结构和虚拟内存函数有深入的理解。从小处着手，使用 `pgtbltest` 中的 `superpg_test` 测试用例频繁测试，并利用 `vmprint` 来调试您的页表。
